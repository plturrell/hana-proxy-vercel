-- Partition news_articles table by month for better performance
-- This will improve query performance for time-based queries and make data maintenance easier

-- Step 1: Check current table size
DO $$
DECLARE
    row_count bigint;
    table_size text;
BEGIN
    SELECT COUNT(*) INTO row_count FROM news_articles;
    SELECT pg_size_pretty(pg_total_relation_size('news_articles')) INTO table_size;
    
    RAISE NOTICE 'Current news_articles table: % rows, % size', row_count, table_size;
END $$;

-- Step 2: Create new partitioned table structure
-- We'll partition by month using RANGE partitioning on published_at
CREATE TABLE IF NOT EXISTS news_articles_partitioned (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    article_id text NOT NULL,
    title text NOT NULL,
    content text,
    url text,
    source text,
    author text,
    published_at timestamptz NOT NULL,
    keywords text[],
    categories text[],
    symbols text[],
    entities jsonb,
    language varchar(10) DEFAULT 'en',
    sentiment varchar(20),
    sentiment_score numeric(3,2),
    market_impact varchar(20),
    market_impact_score numeric(3,2),
    relevance_score numeric(3,2),
    created_at timestamptz DEFAULT NOW(),
    updated_at timestamptz DEFAULT NOW(),
    metadata jsonb,
    CONSTRAINT news_articles_partitioned_pkey PRIMARY KEY (id, published_at),
    CONSTRAINT news_articles_partitioned_article_id_key UNIQUE (article_id, published_at)
) PARTITION BY RANGE (published_at);

-- Create indexes on the partitioned table
CREATE INDEX idx_news_part_published_at ON news_articles_partitioned (published_at DESC);
CREATE INDEX idx_news_part_article_id ON news_articles_partitioned (article_id);
CREATE INDEX idx_news_part_source_date ON news_articles_partitioned (source, published_at DESC);
CREATE INDEX idx_news_part_symbols ON news_articles_partitioned USING gin (symbols);
CREATE INDEX idx_news_part_keywords ON news_articles_partitioned USING gin (keywords);

-- Step 3: Create partitions for the last 12 months and next 3 months
DO $$
DECLARE
    start_date date;
    end_date date;
    partition_name text;
    i integer;
BEGIN
    -- Create partitions for the past 12 months
    FOR i IN 0..11 LOOP
        start_date := date_trunc('month', CURRENT_DATE - (i || ' months')::interval)::date;
        end_date := (start_date + interval '1 month')::date;
        partition_name := 'news_articles_y' || to_char(start_date, 'YYYY') || 'm' || to_char(start_date, 'MM');
        
        -- Check if partition already exists
        IF NOT EXISTS (
            SELECT 1 FROM pg_class c
            JOIN pg_namespace n ON c.relnamespace = n.oid
            WHERE c.relname = partition_name AND n.nspname = 'public'
        ) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF news_articles_partitioned
                FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
            RAISE NOTICE 'Created partition % for % to %', partition_name, start_date, end_date;
        END IF;
    END LOOP;
    
    -- Create partitions for the next 3 months
    FOR i IN 1..3 LOOP
        start_date := date_trunc('month', CURRENT_DATE + (i || ' months')::interval)::date;
        end_date := (start_date + interval '1 month')::date;
        partition_name := 'news_articles_y' || to_char(start_date, 'YYYY') || 'm' || to_char(start_date, 'MM');
        
        IF NOT EXISTS (
            SELECT 1 FROM pg_class c
            JOIN pg_namespace n ON c.relnamespace = n.oid
            WHERE c.relname = partition_name AND n.nspname = 'public'
        ) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF news_articles_partitioned
                FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
            RAISE NOTICE 'Created partition % for % to %', partition_name, start_date, end_date;
        END IF;
    END LOOP;
    
    -- Create default partition for any data outside the defined ranges
    IF NOT EXISTS (
        SELECT 1 FROM pg_class c
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE c.relname = 'news_articles_default' AND n.nspname = 'public'
    ) THEN
        CREATE TABLE news_articles_default PARTITION OF news_articles_partitioned DEFAULT;
        RAISE NOTICE 'Created default partition';
    END IF;
END $$;

-- Step 4: Create function to automatically create new monthly partitions
CREATE OR REPLACE FUNCTION create_monthly_partition()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    start_date date;
    end_date date;
    partition_name text;
BEGIN
    -- Create partition for next month if it doesn't exist
    start_date := date_trunc('month', CURRENT_DATE + interval '1 month')::date;
    end_date := (start_date + interval '1 month')::date;
    partition_name := 'news_articles_y' || to_char(start_date, 'YYYY') || 'm' || to_char(start_date, 'MM');
    
    IF NOT EXISTS (
        SELECT 1 FROM pg_class c
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE c.relname = partition_name AND n.nspname = 'public'
    ) THEN
        EXECUTE format(
            'CREATE TABLE %I PARTITION OF news_articles_partitioned
            FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );
        RAISE NOTICE 'Created partition % for % to %', partition_name, start_date, end_date;
    END IF;
END;
$$;

-- Step 5: Create a function to migrate data from old table to partitioned table
CREATE OR REPLACE FUNCTION migrate_to_partitioned_table(batch_size integer DEFAULT 10000)
RETURNS TABLE(migrated_count bigint, remaining_count bigint)
LANGUAGE plpgsql
AS $$
DECLARE
    v_migrated bigint := 0;
    v_remaining bigint;
    v_batch_migrated integer;
BEGIN
    -- Check how many records need to be migrated
    SELECT COUNT(*) INTO v_remaining
    FROM news_articles n
    WHERE NOT EXISTS (
        SELECT 1 FROM news_articles_partitioned p
        WHERE p.article_id = n.article_id
    );
    
    RAISE NOTICE 'Starting migration of % records', v_remaining;
    
    -- Migrate in batches
    LOOP
        WITH batch AS (
            SELECT * FROM news_articles n
            WHERE NOT EXISTS (
                SELECT 1 FROM news_articles_partitioned p
                WHERE p.article_id = n.article_id
            )
            LIMIT batch_size
        )
        INSERT INTO news_articles_partitioned (
            article_id, title, content, url, source, author,
            published_at, keywords, categories, symbols, entities,
            language, sentiment, sentiment_score, market_impact,
            market_impact_score, relevance_score, created_at, updated_at, metadata
        )
        SELECT 
            article_id, title, content, url, source, author,
            COALESCE(published_at, created_at, NOW()), -- Ensure published_at is not null
            keywords, categories, symbols, entities,
            language, sentiment, sentiment_score, market_impact,
            market_impact_score, relevance_score, created_at, updated_at, metadata
        FROM batch
        ON CONFLICT (article_id, published_at) DO NOTHING;
        
        GET DIAGNOSTICS v_batch_migrated = ROW_COUNT;
        v_migrated := v_migrated + v_batch_migrated;
        
        -- Exit if no more rows to migrate
        EXIT WHEN v_batch_migrated = 0;
        
        -- Optional: Add a small delay to reduce load
        PERFORM pg_sleep(0.1);
        
        RAISE NOTICE 'Migrated % records so far...', v_migrated;
    END LOOP;
    
    -- Get final remaining count
    SELECT COUNT(*) INTO v_remaining
    FROM news_articles n
    WHERE NOT EXISTS (
        SELECT 1 FROM news_articles_partitioned p
        WHERE p.article_id = n.article_id
    );
    
    RETURN QUERY SELECT v_migrated, v_remaining;
END;
$$;

-- Step 6: Create trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_news_articles_partitioned_updated_at
    BEFORE UPDATE ON news_articles_partitioned
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Step 7: Create views and functions for transparent access
CREATE OR REPLACE VIEW news_articles_view AS
SELECT * FROM news_articles_partitioned;

-- Function to insert into partitioned table
CREATE OR REPLACE FUNCTION insert_news_article(
    p_article_id text,
    p_title text,
    p_content text,
    p_source text,
    p_published_at timestamptz,
    p_url text DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO news_articles_partitioned (
        article_id, title, content, source, published_at, url
    ) VALUES (
        p_article_id, p_title, p_content, p_source, 
        COALESCE(p_published_at, NOW()), p_url
    )
    ON CONFLICT (article_id, published_at) DO UPDATE SET
        title = EXCLUDED.title,
        content = EXCLUDED.content,
        updated_at = NOW();
END;
$$;

-- Step 8: Maintenance function to drop old partitions
CREATE OR REPLACE FUNCTION drop_old_partitions(months_to_keep integer DEFAULT 12)
RETURNS TABLE(dropped_partition text)
LANGUAGE plpgsql
AS $$
DECLARE
    partition_record record;
    cutoff_date date;
BEGIN
    cutoff_date := date_trunc('month', CURRENT_DATE - (months_to_keep || ' months')::interval)::date;
    
    FOR partition_record IN 
        SELECT 
            schemaname,
            tablename,
            pg_get_expr(c.relpartbound, c.oid) as partition_expression
        FROM pg_tables t
        JOIN pg_class c ON c.relname = t.tablename
        JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname = t.schemaname
        WHERE t.schemaname = 'public' 
        AND t.tablename LIKE 'news_articles_y%'
        AND c.relispartition
    LOOP
        -- Extract the date from partition boundary
        IF partition_record.partition_expression ~ 'FOR VALUES FROM \(''(\d{4}-\d{2}-\d{2})''\)' THEN
            IF (substring(partition_record.partition_expression from 'FOR VALUES FROM \(''(\d{4}-\d{2}-\d{2})''\)')::date) < cutoff_date THEN
                EXECUTE format('DROP TABLE %I.%I', partition_record.schemaname, partition_record.tablename);
                dropped_partition := partition_record.tablename;
                RETURN NEXT;
            END IF;
        END IF;
    END LOOP;
END;
$$;

-- Step 9: Enable RLS on partitioned table
ALTER TABLE news_articles_partitioned ENABLE ROW LEVEL SECURITY;

-- Copy RLS policies from original table
DO $$
DECLARE
    policy_record record;
BEGIN
    FOR policy_record IN 
        SELECT policyname, cmd, qual, with_check, roles
        FROM pg_policies
        WHERE schemaname = 'public' AND tablename = 'news_articles'
    LOOP
        EXECUTE format(
            'CREATE POLICY %I ON news_articles_partitioned FOR %s TO %s USING (%s) WITH CHECK (%s)',
            policy_record.policyname || '_partitioned',
            policy_record.cmd,
            array_to_string(policy_record.roles, ', '),
            COALESCE(policy_record.qual, 'true'),
            COALESCE(policy_record.with_check, 'true')
        );
    END LOOP;
END $$;

-- Step 10: Grant permissions
GRANT ALL ON news_articles_partitioned TO postgres;
GRANT SELECT, INSERT, UPDATE, DELETE ON news_articles_partitioned TO authenticated, service_role;
GRANT SELECT ON news_articles_view TO authenticated, anon;
GRANT EXECUTE ON FUNCTION migrate_to_partitioned_table TO postgres;
GRANT EXECUTE ON FUNCTION create_monthly_partition TO postgres, service_role;
GRANT EXECUTE ON FUNCTION drop_old_partitions TO postgres;
GRANT EXECUTE ON FUNCTION insert_news_article TO authenticated, service_role;

-- Summary
DO $$
BEGIN
    RAISE NOTICE E'\n=== News Articles Partitioning Setup Complete ===';
    RAISE NOTICE '1. Created partitioned table: news_articles_partitioned';
    RAISE NOTICE '2. Created partitions for last 12 months + next 3 months';
    RAISE NOTICE '3. Created maintenance functions';
    RAISE NOTICE '4. Ready for migration';
    RAISE NOTICE '';
    RAISE NOTICE 'To migrate data, run: SELECT * FROM migrate_to_partitioned_table();';
    RAISE NOTICE 'To switch over after migration:';
    RAISE NOTICE '  1. Verify all data is migrated';
    RAISE NOTICE '  2. Rename tables to swap them';
    RAISE NOTICE '  3. Update application to use new table';
END $$;