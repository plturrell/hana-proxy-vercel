-- Complete News Articles Partitioning Setup
-- Creates partitioned table and migration functions

-- Step 1: Check current table
DO $$
DECLARE
    row_count bigint;
    table_size text;
BEGIN
    SELECT COUNT(*) INTO row_count FROM news_articles;
    SELECT pg_size_pretty(pg_total_relation_size('news_articles')) INTO table_size;
    RAISE NOTICE 'Current news_articles: % rows, %', row_count, table_size;
END $$;

-- Step 2: Create partitioned table
CREATE TABLE IF NOT EXISTS news_articles_partitioned (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    article_id text NOT NULL,
    title text NOT NULL,
    content text,
    url text,
    source text,
    author text,
    published_at timestamptz NOT NULL,
    keywords text[],
    categories text[],
    symbols text[],
    entities jsonb,
    language varchar(10) DEFAULT 'en',
    sentiment varchar(20),
    sentiment_score numeric(3,2),
    market_impact varchar(20),
    market_impact_score numeric(3,2),
    relevance_score numeric(3,2),
    created_at timestamptz DEFAULT NOW(),
    updated_at timestamptz DEFAULT NOW(),
    metadata jsonb,
    CONSTRAINT news_articles_partitioned_pkey PRIMARY KEY (id, published_at),
    CONSTRAINT news_articles_partitioned_article_id_key UNIQUE (article_id, published_at)
) PARTITION BY RANGE (published_at);

-- Step 3: Create indexes
CREATE INDEX IF NOT EXISTS idx_news_part_published ON news_articles_partitioned (published_at DESC);
CREATE INDEX IF NOT EXISTS idx_news_part_article_id ON news_articles_partitioned (article_id);
CREATE INDEX IF NOT EXISTS idx_news_part_source ON news_articles_partitioned (source, published_at DESC);

-- Step 4: Create partitions
DO $$
DECLARE
    start_date date;
    end_date date;
    partition_name text;
    i integer;
BEGIN
    -- Past 12 months
    FOR i IN 0..11 LOOP
        start_date := date_trunc('month', CURRENT_DATE - (i || ' months')::interval)::date;
        end_date := (start_date + interval '1 month')::date;
        partition_name := 'news_articles_y' || to_char(start_date, 'YYYY') || 'm' || to_char(start_date, 'MM');
        
        IF NOT EXISTS (
            SELECT 1 FROM pg_class WHERE relname = partition_name
        ) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF news_articles_partitioned FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
            RAISE NOTICE 'Created partition %', partition_name;
        END IF;
    END LOOP;
    
    -- Next 3 months
    FOR i IN 1..3 LOOP
        start_date := date_trunc('month', CURRENT_DATE + (i || ' months')::interval)::date;
        end_date := (start_date + interval '1 month')::date;
        partition_name := 'news_articles_y' || to_char(start_date, 'YYYY') || 'm' || to_char(start_date, 'MM');
        
        IF NOT EXISTS (
            SELECT 1 FROM pg_class WHERE relname = partition_name
        ) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF news_articles_partitioned FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
            RAISE NOTICE 'Created partition %', partition_name;
        END IF;
    END LOOP;
    
    -- Default partition
    IF NOT EXISTS (
        SELECT 1 FROM pg_class WHERE relname = 'news_articles_default'
    ) THEN
        CREATE TABLE news_articles_default PARTITION OF news_articles_partitioned DEFAULT;
        RAISE NOTICE 'Created default partition';
    END IF;
END $$;

-- Step 5: Enable RLS and create policies
ALTER TABLE news_articles_partitioned ENABLE ROW LEVEL SECURITY;

-- Basic RLS policies
CREATE POLICY "Read access for authenticated" ON news_articles_partitioned
    FOR SELECT TO authenticated USING (true);

CREATE POLICY "Write access for service role" ON news_articles_partitioned
    FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "Insert for authenticated" ON news_articles_partitioned
    FOR INSERT TO authenticated WITH CHECK (true);

-- Step 6: Migration function
CREATE OR REPLACE FUNCTION migrate_news_to_partitioned(batch_size integer DEFAULT 1000)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    migrated_total bigint := 0;
    batch_count integer;
    start_time timestamptz := clock_timestamp();
BEGIN
    LOOP
        WITH batch AS (
            SELECT * FROM news_articles n
            WHERE NOT EXISTS (
                SELECT 1 FROM news_articles_partitioned p
                WHERE p.article_id = n.article_id
            )
            LIMIT batch_size
        )
        INSERT INTO news_articles_partitioned (
            article_id, title, content, url, source,
            published_at, created_at, updated_at
        )
        SELECT 
            article_id, title, content, url, source,
            COALESCE(published_at, created_at, NOW()),
            created_at, updated_at
        FROM batch
        ON CONFLICT (article_id, published_at) DO NOTHING;
        
        GET DIAGNOSTICS batch_count = ROW_COUNT;
        migrated_total := migrated_total + batch_count;
        
        EXIT WHEN batch_count = 0;
        PERFORM pg_sleep(0.01); -- Small delay to reduce load
    END LOOP;
    
    RETURN jsonb_build_object(
        'migrated', migrated_total,
        'duration', clock_timestamp() - start_time,
        'status', 'complete'
    );
END;
$$;

-- Step 7: Auto-partition creation
CREATE OR REPLACE FUNCTION create_next_month_partition()
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
    start_date date;
    end_date date;
    partition_name text;
BEGIN
    start_date := date_trunc('month', CURRENT_DATE + interval '1 month')::date;
    end_date := (start_date + interval '1 month')::date;
    partition_name := 'news_articles_y' || to_char(start_date, 'YYYY') || 'm' || to_char(start_date, 'MM');
    
    IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
        EXECUTE format(
            'CREATE TABLE %I PARTITION OF news_articles_partitioned FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );
        RETURN 'Created partition: ' || partition_name;
    ELSE
        RETURN 'Partition already exists: ' || partition_name;
    END IF;
END;
$$;

-- Step 8: Updated timestamp trigger
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_news_partitioned_timestamp
    BEFORE UPDATE ON news_articles_partitioned
    FOR EACH ROW
    EXECUTE FUNCTION update_timestamp();

-- Step 9: Maintenance function
CREATE OR REPLACE FUNCTION maintain_partitions(months_to_keep integer DEFAULT 12)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    dropped_count integer := 0;
    created_count integer := 0;
    partition_name text;
    cutoff_date date;
BEGIN
    -- Create future partitions
    PERFORM create_next_month_partition();
    created_count := 1;
    
    -- Drop old partitions (optional, uncomment to enable)
    -- cutoff_date := date_trunc('month', CURRENT_DATE - (months_to_keep || ' months')::interval)::date;
    -- FOR partition_name IN 
    --     SELECT tablename FROM pg_tables 
    --     WHERE schemaname = 'public' 
    --     AND tablename ~ '^news_articles_y\d{4}m\d{2}$'
    --     AND tablename < 'news_articles_y' || to_char(cutoff_date, 'YYYYMM')
    -- LOOP
    --     EXECUTE format('DROP TABLE %I', partition_name);
    --     dropped_count := dropped_count + 1;
    -- END LOOP;
    
    RETURN jsonb_build_object(
        'created', created_count,
        'dropped', dropped_count,
        'timestamp', NOW()
    );
END;
$$;

-- Step 10: Query optimization view
CREATE OR REPLACE VIEW news_articles_current AS
SELECT * FROM news_articles_partitioned
WHERE published_at > CURRENT_DATE - interval '30 days';

-- Step 11: Permissions
GRANT ALL ON news_articles_partitioned TO postgres;
GRANT SELECT, INSERT, UPDATE, DELETE ON news_articles_partitioned TO authenticated, service_role;
GRANT SELECT ON news_articles_current TO authenticated, anon;
GRANT EXECUTE ON FUNCTION migrate_news_to_partitioned TO postgres, service_role;
GRANT EXECUTE ON FUNCTION create_next_month_partition TO postgres, service_role;
GRANT EXECUTE ON FUNCTION maintain_partitions TO postgres, service_role;

-- Step 12: Summary
DO $$
DECLARE
    partition_count integer;
BEGIN
    SELECT COUNT(*) INTO partition_count
    FROM pg_class c
    JOIN pg_inherits i ON c.oid = i.inhrelid
    WHERE i.inhparent = 'news_articles_partitioned'::regclass;
    
    RAISE NOTICE E'\n=== Partitioning Setup Complete ===';
    RAISE NOTICE 'Created % partitions', partition_count;
    RAISE NOTICE 'Table: news_articles_partitioned';
    RAISE NOTICE '';
    RAISE NOTICE 'To migrate data:';
    RAISE NOTICE '  SELECT migrate_news_to_partitioned();';
    RAISE NOTICE '';
    RAISE NOTICE 'Benefits:';
    RAISE NOTICE '  - Faster queries on date ranges';
    RAISE NOTICE '  - Easier data archival';
    RAISE NOTICE '  - Better vacuum performance';
    RAISE NOTICE '  - Partition pruning for queries';
END $$;